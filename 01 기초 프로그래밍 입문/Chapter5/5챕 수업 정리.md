# 📘 C# 객체 지향 정리

## 🔹 값 타입 vs 참조 타입

- **Struct (구조체)** : 값 타입 → 복사 시 값 자체가 복제됨
- **Class (클래스)** : 참조 타입 → 주소(참조)가 넘어가므로 원본 변경 가능

---

## 🔹 스택과 힙

- **스택**
    - 일시적인 메모리 / 메모장 같은 존재
    - 값 타입 저장
    - 포인터도 존재
- **힙**
    - 동적으로 할당되는 메모리 공간
    - 참조 타입 저장
- **복사 vs 참조**
    - 복사 : 본체(값)를 담음
    - 참조 : 주소를 담음
- `delete` 키워드 없음 → **GC(가비지 컬렉터)** 가 자동 처리

---

## 🔹 생성자(Constructor)

```csharp
public Knight()
{
    hp = 100;
    attack = 10;
    Console.WriteLine("생성자 호출!");
}

public Knight(int hp) : this()
{
    this.hp = hp;
    Console.WriteLine("int 생성자 호출");
}

```

- `: this()` → 기본 생성자 호출 후 값 수정 가능
- `: base(값)` → 부모 생성자 호출

---

## 🔹 static

- 클래스 단위로 하나만 존재
- 인스턴스 개수와 무관
- `클래스명.함수명()` 으로 호출
- `static` 메서드는 **인스턴스 변수 접근 불가**

---

## 🔹 상속(Inheritance)

- OOP 3대 특징: **은닉성 / 상속성 / 다형성**
- 자식 생성자 호출 시 **부모 → 자식 순**으로 실행
- `base` 키워드로 부모 생성자 호출 가능
- 자식은 부모의 **필드/메서드 사용 가능**

---

## 🔹 은닉성(Encapsulation)

- `private` : 외부 접근 불가 (getter/setter 활용)
- `protected` : 자식 및 그 하위 클래스까지 접근 가능

---

## 🔹 클래스 형식 변환

```csharp
static void EnterGame(Player player)

EnterGame(knight);
EnterGame(mage);

```

- 부모 타입 매개변수에 자식 클래스 전달 가능 (**업캐스팅**)
- **다운캐스팅** 시 안전 확인 필요

```csharp
// 방법 1 : is
if (player is Mage)
{
    Mage mage = (Mage)player;
    mage.mp = 10;
}

// 방법 2 : as
Mage mage = player as Mage;
if (mage != null)
{
    mage.mp = 10;
}

```

---

## 🔹 다형성(Polymorphism)

- **오버로드 (Overload)** : 같은 이름, 매개변수 다름 → 함수 중복 정의
- **오버라이딩 (Override)** : 부모 메서드 재정의

```csharp
public virtual void Move() { }

public override void Move() {
    base.Move(); // 부모 기능 + 확장
}

// 이후 상속에서 재정의 불가
public sealed override void Move() { }

```

---

## 🔹 문자열 다루기

```csharp
bool found = name.Contains("Harry");
int index = name.IndexOf("P");

string lower = name.ToLower();
string upper = name.ToUpper();
string newName = name.Replace('r', 'l');

string[] names = name.Split(new char[] { ' ' });
string sub = name.Substring(5);

```